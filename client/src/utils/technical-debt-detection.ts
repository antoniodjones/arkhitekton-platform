// Technical Debt Detection and Correlation Logic

export interface TechnicalDebtRiskIndicators {
  highRisk: boolean;
  riskScore: number;
  riskFactors: string[];
  suggestedDebtType: 'architecture' | 'security' | 'performance' | 'maintenance' | 'code_quality';
  suggestedSeverity: 'medium' | 'high' | 'critical';
  autoGeneratedTitle: string;
  autoGeneratedProblem: string;
  autoGeneratedSolution: string;
}

export interface ADRData {
  technicalDebtScore?: number;
  riskAssessment?: 'low' | 'medium' | 'high' | 'critical';
  decisionCategory?: 'strategic' | 'technical' | 'security' | 'data' | 'infrastructure';
  consequences?: Array<{
    type: 'positive' | 'negative' | 'neutral';
    description: string;
    impact: 'low' | 'medium' | 'high';
    timeframe: 'immediate' | 'short_term' | 'long_term';
  }>;
  maintenanceImpact?: string;
  operationalImpact?: string;
  affectedSystems?: string[];
  context?: string;
  decision?: string;
  title: string;
}

export function detectTechnicalDebtRisk(adrData: ADRData): TechnicalDebtRiskIndicators {
  const riskFactors: string[] = [];
  let riskScore = 0;
  let suggestedDebtType: TechnicalDebtRiskIndicators['suggestedDebtType'] = 'architecture';
  let suggestedSeverity: TechnicalDebtRiskIndicators['suggestedSeverity'] = 'medium';

  // High Technical Debt Score (7-10)
  if (adrData.technicalDebtScore && adrData.technicalDebtScore >= 7) {
    riskFactors.push(`High technical debt score (${adrData.technicalDebtScore}/10)`);
    riskScore += adrData.technicalDebtScore >= 9 ? 30 : 20;
    
    if (adrData.technicalDebtScore >= 9) {
      suggestedSeverity = 'critical';
    } else if (adrData.technicalDebtScore >= 8) {
      suggestedSeverity = 'high';
    }
  }

  // High Risk Assessment
  if (adrData.riskAssessment === 'high' || adrData.riskAssessment === 'critical') {
    riskFactors.push(`${adrData.riskAssessment} risk assessment`);
    riskScore += adrData.riskAssessment === 'critical' ? 25 : 15;
    
    if (adrData.riskAssessment === 'critical') {
      suggestedSeverity = 'critical';
    }
  }

  // Negative High-Impact Consequences
  const negativeHighImpactConsequences = adrData.consequences?.filter(
    c => c.type === 'negative' && c.impact === 'high'
  ) || [];
  
  if (negativeHighImpactConsequences.length > 0) {
    riskFactors.push(`${negativeHighImpactConsequences.length} high-impact negative consequence(s)`);
    riskScore += negativeHighImpactConsequences.length * 10;
  }

  // Long-term Negative Consequences
  const longTermNegativeConsequences = adrData.consequences?.filter(
    c => c.type === 'negative' && c.timeframe === 'long_term'
  ) || [];
  
  if (longTermNegativeConsequences.length > 0) {
    riskFactors.push(`${longTermNegativeConsequences.length} long-term negative consequence(s)`);
    riskScore += longTermNegativeConsequences.length * 8;
  }

  // Maintenance Impact Indicators
  if (adrData.maintenanceImpact && 
      (adrData.maintenanceImpact.toLowerCase().includes('significant') ||
       adrData.maintenanceImpact.toLowerCase().includes('increased') ||
       adrData.maintenanceImpact.toLowerCase().includes('complex'))) {
    riskFactors.push('Significant maintenance impact identified');
    riskScore += 15;
    suggestedDebtType = 'maintenance';
  }

  // Decision Category Mapping
  switch (adrData.decisionCategory) {
    case 'security':
      if (riskScore > 0) {
        suggestedDebtType = 'security';
        riskScore += 5; // Security debt is critical
      }
      break;
    case 'infrastructure':
      if (riskScore > 0) {
        suggestedDebtType = 'architecture';
      }
      break;
    case 'technical':
      if (riskScore > 0) {
        suggestedDebtType = 'code_quality';
      }
      break;
  }

  // Multiple Affected Systems
  if (adrData.affectedSystems && adrData.affectedSystems.length > 3) {
    riskFactors.push(`Multiple systems affected (${adrData.affectedSystems.length})`);
    riskScore += 10;
  }

  // Generate auto-populated content
  const autoGeneratedTitle = generateDebtTitle(adrData, suggestedDebtType);
  const autoGeneratedProblem = generateProblemDescription(adrData, negativeHighImpactConsequences);
  const autoGeneratedSolution = generateSolutionDescription(adrData);

  return {
    highRisk: riskScore >= 40, // Threshold for high risk
    riskScore,
    riskFactors,
    suggestedDebtType,
    suggestedSeverity,
    autoGeneratedTitle,
    autoGeneratedProblem,
    autoGeneratedSolution
  };
}

function generateDebtTitle(adrData: ADRData, debtType: string): string {
  const typeMap = {
    'architecture': 'Architecture',
    'security': 'Security',
    'performance': 'Performance',
    'maintenance': 'Maintenance',
    'code_quality': 'Code Quality'
  };
  
  return `${typeMap[debtType as keyof typeof typeMap] || 'Technical'} Technical Debt from: ${adrData.title}`;
}

function generateProblemDescription(adrData: ADRData, negativeConsequences: Array<{description: string}>): string {
  let problem = `Technical debt introduced by architectural decision: ${adrData.title}\n\n`;
  
  if (adrData.context) {
    problem += `Context: ${adrData.context}\n\n`;
  }
  
  if (negativeConsequences.length > 0) {
    problem += `Identified negative consequences:\n`;
    negativeConsequences.forEach((consequence, index) => {
      problem += `${index + 1}. ${consequence.description}\n`;
    });
    problem += '\n';
  }
  
  if (adrData.maintenanceImpact) {
    problem += `Maintenance Impact: ${adrData.maintenanceImpact}\n`;
  }
  
  if (adrData.operationalImpact) {
    problem += `Operational Impact: ${adrData.operationalImpact}`;
  }
  
  return problem.trim();
}

function generateSolutionDescription(adrData: ADRData): string {
  let solution = 'Address the technical debt introduced by this architectural decision through:\n\n';
  
  solution += '1. Regular monitoring of the identified negative consequences\n';
  solution += '2. Scheduled refactoring to reduce complexity and maintenance burden\n';
  solution += '3. Implementation of mitigating measures for high-impact areas\n';
  
  if (adrData.affectedSystems && adrData.affectedSystems.length > 0) {
    solution += `4. Focus remediation efforts on affected systems: ${adrData.affectedSystems.join(', ')}\n`;
  }
  
  solution += '5. Establish metrics to track debt accumulation and reduction progress';
  
  return solution;
}

export function mapDebtScoreToSeverity(score?: number): 'low' | 'medium' | 'high' | 'critical' {
  if (!score) return 'medium';
  if (score >= 9) return 'critical';
  if (score >= 7) return 'high';
  if (score >= 5) return 'medium';
  return 'low';
}